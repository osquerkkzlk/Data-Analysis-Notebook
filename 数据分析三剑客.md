# 数据分析三剑客







# 1、numpy 包

------

## 1. **导入 NumPy**

```python
import numpy as np
```

------

## 2. **创建数组**

### (1) 从列表创建数组

```python
arr = np.array([1, 2, 3, 4, 5])
print(arr)  # [1 2 3 4 5]
```

### (2) 创建多维数组

```python
arr2d = np.array([[1, 2, 3], [4, 5, 6]])
print(arr2d)
```

### (3) 生成特殊数组

```python
np.zeros((2, 3))    # 创建 2×3 全零数组
np.ones((3, 3))     # 创建 3×3 全一数组
np.full((2, 2), 7)  # 创建 2×2 值为 7 的数组
np.eye(4)           # 创建 4×4 单位矩阵
np.empty((3, 3))    # 创建未初始化的 3×3 数组（值不确定）
```

### (4) 生成等差数列

```python
np.arange(0, 10, 2)  # [0 2 4 6 8]
np.linspace(0, 1, 5)  # 生成 5 个等间距的点 [0.   0.25 0.5  0.75 1.  ]
```

### (5) 生成随机数组

```python
np.random.rand(2, 3)        # 生成 2×3 的 0-1 之间均匀分布的随机数
np.random.randn(3, 3)       # 生成 3×3 的标准正态分布随机数
np.random.randint(1, 10, (2, 2))  # 生成 1 到 10 之间的随机整数数组
```

------

## 3. **数组属性**

```python
arr.shape  # 获取数组形状，如 (3, 4)
arr.size   # 获取数组元素总数
arr.dtype  # 获取数组数据类型
arr.ndim   # 获取数组维度
```

------

## 4. **数组运算**

### (1) 数学运算

```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print(a + b)  # [5 7 9]
print(a - b)  # [-3 -3 -3]
print(a * b)  # [ 4 10 18]
print(a / b)  # [0.25 0.4  0.5 ]
print(np.exp(a))  # e^a
print(np.sqrt(a))  # 开平方
print(np.log(a))  # 取对数
```

### (2) 聚合函数

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(np.sum(arr))  # 求和
print(np.mean(arr))  # 求均值
print(np.max(arr))  # 最大值
print(np.min(arr))  # 最小值
print(np.std(arr))  # 标准差
print(np.var(arr))  # 方差
print(np.(arr))  # 最大值索引
print(np.argmin(arr))  # 最小值索引
print(arr.mean()) #计算平均值
print(arr.median()) #计算中位数
print(arr.cumsum()) #计算累加
print(arr.diff()) #计算累差
print(arr.nonzero()) #找出非零的数字
print(arr.sort()) #逐行进行排序，每一行之间不会干扰
print(arr.T) 或 者print(arr.transpose()) #对矩阵进行转置
print(arr.clip(a,b)) #让矩阵中小于a的数字都变成a，所有大于b的数字都变成b
```

### (3) 按轴计算

```python
np.sum(arr, axis=0)  # 按列求和
np.sum(arr, axis=1)  # 按行求和
```

------

## 5. **数组索引和切片**

### (1) 一维数组索引

```python
arr = np.array([10, 20, 30, 40])
print(arr[2])  # 30
print(arr[-1])  # 40
```

### (2) 多维数组索引

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[1, 2])  # 6，当然也可以写成arr[1][2]✔️
print(arr[0, :])  # 取第一行
print(arr[:, 1])  # 取第二列
print(arr[0:2, 1:3])  # 取左上角 2×2 矩阵
```

### (3) 条件索引

```python
arr = np.array([10, 20, 30, 40, 50])
print(arr[arr > 25])  # [30 40 50]
```

------

## 6. **数组变形和拼接**

### (1) 变形

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr.reshape(3, 2))  # 变成 3×2,reshape方法可以改变矩阵的空间构型,当然也可以实现矩阵的转置
print(arr.flatten())  # 展平成 1D  数组
```

### (2) 拼接

```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6]])

print(np.vstack((a, b)))  # 垂直拼接
print(np.hstack((a, b.T)))  # 水平拼接（b 需要转置）
```

### (3) 拆分

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(np.split(arr, 3, axis=1))  # 按列拆分
print(np.split(arr, 2, axis=0))  # 按行拆分
#进行不等量的分割
print(np.array_split(arr,2,axis=1))
print(np.vsplit(arr,2)) #纵向分割，也就是上下分割
print(np.hsplit(arr,3)) #横向分割，也就是左右分割
```

------

## 7. **广播机制**

`NumPy `允许形状不同的数组进行运算，例如：

```python
a = np.array([[1], [2], [3]])
b = np.array([10, 20, 30])
print(a + b)  
# [[11 21 31]
#  [12 22 32]
#  [13 23 33]]
```

NumPy 会自动扩展较小的数组，使其形状匹配较大的数组。

------

## 8. **线性代数**

```python
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

print(np.dot(A, B))  # 矩阵乘法
print(A @ B)  # 矩阵乘法的简写
print(np.linalg.inv(A))  # 逆矩阵
print(np.linalg.det(A))  # 矩阵行列式
print(np.linalg.eig(A))  # 特征值和特征向量
```

------

## 9. **随机数与随机数种子**

```python
np.random.seed(42)  # 保证随机数可复现
```

------

`np.random.rand` 是 `NumPy` 库中的一个函数，用于生成指定形状的随机数组，数组中的元素是从 `[0, 1)` 区间内均匀分布的随机数（即 0 到 1 之间，不包含 1）。它是 `NumPy `随机模块（`numpy.random`）的一部分，常用于生成模拟数据或初始化随机值。

### 语法

```python
np.random.rand(d0, d1, ..., dn)
```

- **`d0, d1, ..., dn`**：指定生成数组的形状（维度）。可以传入任意数量的整数参数，表示多维数组的大小。
- **返回值**：一个形状为 `(d0, d1, ..., dn)` 的 NumPy 数组，元素为 `[0, 1)` 之间的随机浮点数。

### 示例

1. **生成单个随机数（标量）**：
   如果不传参数，`np.random.rand()` 会报错。

   ==要生成单个随机数，可以用 `np.random.random()` 或明确指定形状。==

   ```python
   import numpy as np
   print(np.random.rand(1)[0])  # 生成一个数，例如 0.5488135039273248
   ```

2. **生成一维数组**：

   ```python
   import numpy as np
   print(np.random.rand(3))  # 生成 3 个随机数
   ```

   输出示例：

   ```
   [0.5488135  0.71518937 0.60276338]
   ```

3. **生成二维数组**：

   ```python
   import numpy as np
   print(np.random.rand(2, 3))  # 生成 2x3 的随机数组
   ```

   输出示例：

   ```
   [[0.54488318 0.4236548  0.64589411]
    [0.43758721 0.891773   0.96366276]]
   ```

### 特点

- **均匀分布**：生成的随机数服从 `[0, 1)` 的均匀分布。
- **每次运行不同**：除非设置随机种子（`np.random.seed()`），否则每次生成的数都不同。
- **与 `np.random.random` 的区别**：
  - `np.random.rand` 使用形状参数直接指定维度（如 `rand(2, 3)`）。
  - `np.random.random` 需要传入一个元组（如 `random((2, 3))`）。

### 设置随机种子

为了让结果可重复，可以使用 `np.random.seed()`：

```python
import numpy as np
np.random.seed(42)  # 设置种子为 42
print(np.random.rand(3))
```

输出（固定结果）：

```
[0.37454012 0.95071431 0.73199394]
```



## 10.矩阵循环

### 1、利用嵌套for循环

示例：直接用 `for` 循环遍历二维数组

```python
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])

# 直接对矩阵进行嵌套的 for 循环
for row in arr:
    for element in row:
        print(element, end=' ')  # 输出：1 2 3 4 5 6
```

解释：

- `for row in arr:` 遍历数组的每一行。
- `for element in row:` 遍历当前行的每一个元素。

这种方式适用于任何维度的数组，只不过对于更高维度的数组，循环会更加复杂。如果是三维或更高维度的数组，你可能需要增加更多的 `for` 循环层次。

例如，对于三维数组：

```python
arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])

for matrix in arr:
    for row in matrix:
        for element in row:
            print(element, end=' ')  # 输出：1 2 3 4 5 6 7 8
```

直接使用 `for` 循环访问 NumPy 数组的元素是完全可以的，但对于更复杂的操作，`flat` 或 `flatten` 等方法可能会更简洁。

### 2、利用flat属性

`arr.flat()` 不是正确的调用方式，`flat` 是 `NumPy` 中数组的一个属性，而不是一个方法。正确的语法应该是：

```python
print(arr.flat)
```

`arr.flat` 返回一个迭代器，可以遍历数组的所有元素，类似于展开的视图。

如果你想以一维数组的形式打印所有元素，可以直接使用 `arr.flat`。但如果你想将它转为一个一维数组并输出，可以使用 `arr.flatten()` 方法。示例如下：

#### 示例 1：使用 `arr.flat`（迭代器）

```python
import numpy as np
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr.flat)  # 输出的是一个 flat 对象，你可以迭代它
for item in arr.flat:
    print(item, end=' ')  # 输出：1 2 3 4 5 6
```

#### 示例 2：使用 `arr.flatten()`（返回一维数组）

```python
print(arr.flatten())  # 输出：[1 2 3 4 5 6]
```

#### 区别：

- `arr.flat` 是一个迭代器，你可以遍历数组的元素。
- `arr.flatten()` 返回一个新的一维数组，包含数组所有元素。

如果你只是想打印出数组的元素，`flatten()` 更直接。

## 11.矩阵转置

在 `NumPy` 中，`arr.T` 是用来获取数组的转置的。对于一维数组，转置的效果是没有变化的，因为一维数组的转置结果仍然是原数组。

```python
import numpy as np
arr = np.array([1, 2, 3, 4])

print(arr)  # 输出原始一维数组
print(arr.T)  # 输出一维数组的转置（对一维数组没有影响）
```

输出：

```plaintext
[1 2 3 4]
[1 2 3 4]
```

解释：

- 对于一维数组（如 `[1, 2, 3, 4]`），它的转置操作不会改变它。也就是说，`arr.T` 和 `arr` 是相同的。
- **`arr.T` 只对二维及更高维度的数组有效**，例如矩阵（二维数组）才会真正发生转置，即交换行和列。

==要想对一维矩阵进行转置，也就是让行矩阵变成列矩阵，可进行`reshape`方法==



示例：二维数组转置

```python
arr2 = np.array([[1, 2], [3, 4]])

print(arr2)  # 原始矩阵
print(arr2.T)  # 转置后的矩阵
```

**输出：**

```plaintext
[[1 2]
 [3 4]]

[[1 3]
 [2 4]]
```

在二维数组中，`T` 交换了矩阵的行和列。

总结：

- 对于 **一维数组**，`arr.T` 没有效果，数组保持不变。
- 对于 **二维数组**（矩阵），`arr.T` 会交换行和列，即执行转置操作。

## 12、深浅拷贝的问题

==在`numpy`==中，切片不是一个深拷贝，反而是一个浅拷贝哦

在矩阵（或数组）操作中，理解 `copy` 的概念非常重要，尤其是在像 `NumPy` 这样的库中，矩阵的 **拷贝（copy）** 行为直接影响到数据的共享、修改和内存管理。

#### 1. **矩阵的浅拷贝与深拷贝**

**浅拷贝（View）**：

- **浅拷贝**（view）表示的是创建一个新的对象，但这个对象与原始矩阵共享同一块内存空间。因此，修改新矩阵的内容会影响原始矩阵，反之亦然。
- `NumPy` 中的切片、索引、转置等操作，通常返回的是浅拷贝（视图）。

**深拷贝（Copy）**：

- **深拷贝**（copy）表示创建一个新的对象，并且该对象拥有独立的内存空间，修改新矩阵的内容不会影响原始矩阵，反之亦然。
- `NumPy` 中通过 `.copy()` 方法可以显式地创建深拷贝。

#### 2. **浅拷贝（View）示例**

```python
import numpy as np

# 创建一个矩阵
arr = np.array([[1, 2, 3], [4, 5, 6]])

# 切片操作返回的是一个浅拷贝（视图）
arr_view = arr[0:1, :]

print("原始矩阵：\n", arr)
print("视图矩阵：\n", arr_view)

# 修改视图矩阵
arr_view[0, 0] = 99

# 查看修改后的矩阵
print("修改后的原始矩阵：\n", arr)
print("修改后的视图矩阵：\n", arr_view)
```

**输出：**

```plaintext
原始矩阵：
 [[1 2 3]
 [4 5 6]]
视图矩阵：
 [[1 2 3]]
修改后的原始矩阵：
 [[99  2  3]
 [ 4  5  6]]
修改后的视图矩阵：
 [[99  2  3]]
```

#### 解释：

- `arr_view = arr[0:1, :]` 创建了原始矩阵 `arr` 的一个切片，返回的是一个 **浅拷贝**（视图）。
- 修改视图 `arr_view` 中的元素，会影响到原始矩阵 `arr`，因为它们共享同一块内存。

#### 3. **深拷贝（Copy）示例**

如果你不希望矩阵的修改影响到原始矩阵，可以使用 `.copy()` 创建一个深拷贝：

```python
import numpy as np

# 创建一个矩阵
arr = np.array([[1, 2, 3], [4, 5, 6]])

# 使用 .copy() 创建一个深拷贝
arr_copy = arr.copy()

print("原始矩阵：\n", arr)
print("深拷贝矩阵：\n", arr_copy)

# 修改深拷贝矩阵
arr_copy[0, 0] = 99

# 查看修改后的矩阵
print("修改后的原始矩阵：\n", arr)
print("修改后的深拷贝矩阵：\n", arr_copy)
```

**输出：**

```plaintext
原始矩阵：
 [[1 2 3]
 [4 5 6]]
深拷贝矩阵：
 [[1 2 3]
 [4 5 6]]
修改后的原始矩阵：
 [[1 2 3]
 [4 5 6]]
修改后的深拷贝矩阵：
 [[99  2  3]
 [ 4  5  6]]
```

#### 解释：

- `arr_copy = arr.copy()` 创建了一个 **深拷贝**，这意味着 `arr_copy` 和 `arr` 是两个独立的矩阵，它们各自拥有自己的内存空间。
- 修改 `arr_copy` 不会影响原始矩阵 `arr`。

#### 4. **何时使用 `.copy()`？**

在以下情况下，使用 `.copy()` 是非常必要的：

- 当你不希望原始矩阵被修改时（例如，你需要保留原矩阵作为参考），使用 `.copy()` 来创建独立的副本。
- 当你进行矩阵变换（如切片、索引等）并需要修改变换后的矩阵时，使用 `.copy()` 来避免意外地修改原始矩阵。

#### 5. **矩阵切片与 `.copy()` 的区别**

- **切片（浅拷贝）**：使用切片操作时，返回的通常是原矩阵的视图，它与原矩阵共享内存，修改视图会影响原矩阵。
- **`.copy()`（深拷贝）**：使用 `.copy()` 显式创建新的矩阵对象，并复制数据，修改新矩阵不会影响原矩阵。

#### 6. **NumPy 中的 `flags` 属性**

你可以通过 `flags` 属性检查一个 `NumPy` 数组是否是视图（浅拷贝）。如果是视图，`OWNDATA` 标志为 `False`，表示数据是共享的。

示例：

```python
arr = np.array([[1, 2], [3, 4]])
arr_view = arr[0:1, :]

print(arr.flags.owndata)  # True，表示 arr 是独立的内存
print(arr_view.flags.owndata)  # False，表示 arr_view 是 arr 的视图
```

#### 7. **广播与视图**

在进行矩阵广播操作时，`NumPy` 可能会返回视图（浅拷贝）。例如，当你执行标量与矩阵相乘时，矩阵的数据不会被复制，而是会在原有数据上操作，这样能提高效率。

示例：

```python
arr = np.array([[1, 2], [3, 4]])
arr2 = arr * 2  # 广播操作，返回的是视图而非副本
print(arr2)
```

#### 8.小结：

- **浅拷贝（View）**：切片、转置等操作返回的通常是视图，修改视图会影响原矩阵。
- **深拷贝（Copy）**：通过 `.copy()` 方法可以创建独立的副本，修改副本不会影响原矩阵。
- 使用 `.copy()` 可以确保矩阵数据不受外部修改的影响，尤其在进行复杂计算或保存数据时很有用。



## 13、矩阵的常见误区

你的疑问很合理！让我澄清一下 `np.random.rand(1,4)` 生成的数组维度问题，以及它为什么不是一维数组。

#### `np.random.rand(1,4)` 的结果

`np.random.rand(1,4)` 生成的是一个 **二维数组**，其形状（shape）为 `(1, 4)`。这里的 `1` 表示第一维的大小（行数），`4` 表示第二维的大小（列数）。虽然它只有一个“行”，但它仍然是一个二维结构，而不是一维数组。

示例

```python
import numpy as np
array = np.random.rand(1, 4)
print(array)
print(array.shape)
```

输出示例：

```
[[0.37454012 0.95071431 0.73199394 0.59865848]]
(1, 4)
```

- **内容**：一个包含 4 个随机数的“行”。
- **形状**：`(1, 4)`，表示 1 行 4 列。
- **维度**：`array.ndim` 会返回 `2`，确认它是二维的。

#### 为什么不是一维的？

在 `NumPy `中，数组的维度由传入的参数数量决定：

- **`np.random.rand(4)`**：传入一个参数，生成形状为 `(4,)` 的一维数组。
- **`np.random.rand(1, 4)`**：传入两个参数，生成形状为 `(1, 4)` 的二维数组。

即使 `(1, 4)` 的数组看起来像“只有一行”，NumPy 仍然将其视为二维，因为它明确定义了两级结构（行和列）。一维数组的形状是 `(n,)`，没有额外的维度。

#### 一维 vs 二维对比

```python
import numpy as np

# 一维数组
array_1d = np.random.rand(4)
print("1D:", array_1d)
print("Shape:", array_1d.shape)  # (4,)
print("Dim:", array_1d.ndim)     # 1

# 二维数组
array_2d = np.random.rand(1, 4)
print("2D:", array_2d)
print("Shape:", array_2d.shape)  # (1, 4)
print("Dim:", array_2d.ndim)     # 2
```



------

## 14、np.any()方法

看起来你想问的是 NumPy 中的 `np.any()` 函数，而不是 pandas 的 `dropna()` 中的 `how='any'`。没问题，我来用中文为你详细解释 `np.any()` 的用法和功能！

#### `np.any()` 的定义

`numpy.any()` 是 NumPy 库中的一个函数，用于测试数组中是否至少有一个元素满足条件（即为 `True`）。简单来说，它检查数组中“哪怕有一个”元素是 `True`，就返回 `True`。

#### 语法

```python
numpy.any(a, axis=None, out=None, keepdims=False)
```

#### 参数说明

1. **`a`**：输入数组（可以是 NumPy 数组或其他可转换为数组的对象）。
2. **`axis`**：
   - 默认 `None`：对整个数组进行检查。
   - `0`：沿列方向检查。
   - `1`：沿行方向检查。
3. **`out`**：可选的输出数组，用于存储结果（一般很少用）。
4. **`keepdims`**：如果为 `True`，保留减少的维度（结果形状与输入一致）。

#### 返回值

- 如果数组中至少有一个元素为 `True`，返回 `True`。
- 如果所有元素都为 `False`，返回 `False`。

#### 示例

#### 1. 基本用法

```python
import numpy as np

arr = np.array([False, False, True, False])
result = np.any(arr)
print(result)  # 输出：True
```

解释：数组中哪怕有一个 `True`，`np.any()` 就返回 `True`。

#### 2. 全为 False

```python
arr = np.array([False, False, False])
result = np.any(arr)
print(result)  # 输出：False
```

解释：没有一个元素是 `True`，所以返回 `False`。

#### 3. 结合条件

常用来检查数组中是否满足某个条件：

```python
arr = np.array([1, 0, -3, 5])
result = np.any(arr < 0)
print(result)  # 输出：True
```

解释：数组中有一个元素 `-3` 小于 0，哪怕只有一个，`np.any()` 也返回 `True`。

#### 4. 指定轴

对于多维数组，可以沿特定轴检查：

```python
arr = np.array([[0, 0, 1],
                [0, 0, 0]])
result = np.any(arr, axis=0)
print(result)  # 输出：[False False  True]
```

解释：沿列检查（`axis=0`），第三列有 `1`（`True`），所以结果是 `[False, False, True]`。

```python
result = np.any(arr, axis=1)
print(result)  # 输出：[ True False]
```

解释：沿行检查（`axis=1`），第一行有 `1`，第二行全是 `0`，所以结果是 `[True, False]`。

#### 与 `np.all()` 的区别

- `np.any()`：只要有一个 `True` 就返回 `True`。
- `np.all()`：要求所有元素都是 `True` 才返回 `True`。

#### 实际应用

- 检查数组中是否有非零值：`np.any(arr != 0)`。
- 检查是否有缺失值（配合 pandas）：`np.any(pd.isna(df))`。
- 判断条件是否至少在某个地方成立。

## 15、洗牌操作

在 `NumPy` 中，洗牌操作可以通过 `numpy.random.shuffle()` 或 `numpy.random.permutation()` 来实现。两者的区别如下：

### 1. `numpy.random.shuffle()`

`shuffle()` 是一种就地（in-place）操作，它会随机打乱数组的顺序，修改原始数组。

**示例**：

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
np.random.shuffle(arr)  # 直接修改 arr 数组
print(arr)
```

输出（每次运行可能不同）：

```
[4 2 5 1 3]
```

**注意**：`shuffle()` 直接修改原数组，并且仅适用于一维数组。如果你想洗牌多维数组的行，可以对每一行单独进行操作。

### 2. `numpy.random.permutation()`

`permutation()` 返回一个新的数组，数组中的元素是原始数组的洗牌版本，不会修改原始数组。

**示例**：

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
shuffled_arr = np.random.permutation(arr)  # 返回一个新的洗牌数组
print("Original array:", arr)
print("Shuffled array:", shuffled_arr)
```

输出：

```
Original array: [1 2 3 4 5]
Shuffled array: [4 2 1 5 3]
```

### 区别总结：

- `shuffle()` 是就地修改，直接改变原数组。
- `permutation()` 返回一个新的数组，原数组不受影响。

这两个函数都可以用于打乱数据顺序，选择哪个取决于是否希望修改原始数据。

## 16、索引问题

在 NumPy 中，索引二维数组的某一行（self.theta[label_index]）返回一维数组 (3,)，而不是二维的 (1, 3)。这是 NumPy 的默认行为。如果你想要 (1, 3)，需要用切片（如 self.theta[label_index:label_index+1]）。

当你用单个索引（如 arr[0]）访问二维数组的某一行时，NumPy 返回一个一维数组 (3,)，而不是保持二维结构 (1, 3)。

如果你想要得到形状 (1, 3)，可以使用切片或显式索引

```python
import numpy as np
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr[0])
print(arr[0].shape)

print(arr[0:1])        # 输出: [[1 2 3]]
print(arr[0:1].shape)  # 输出: (1, 3)

print(arr[0][np.newaxis, :])        # 输出: [[1 2 3]]
print(arr[0][np.newaxis, :].shape)  # 输出: (1, 3)

```

## 17、meshgrid 

meshgrid 是 NumPy 库中的一个函数，用于从一维坐标数组生成多维网格坐标矩阵。np.meshgrid 的核心功能是将多个一维坐标数组扩展为多维网格的坐标矩阵。给定一维的 x 轴、y 轴（或其他维度）坐标，它生成对应的网格点坐标矩阵，每个矩阵表示一个维度的坐标值。

- **输入**：多个一维数组（通常表示不同维度的坐标）。
- **输出**：多个数组（通常是二维矩阵），表示网格点在每个维度上的坐标值。

最常见的情况是生成二维网格（x-y 平面），但它也支持更高维（如三维 x-y-z 空间）。

```
x0,x1=np.meshgrid(np.linspace(1,2,2).reshape(-1,1),
					np.linspace(10,20,3).reshape(-1,1))
np.c_[x0.ravel(),x1.ravel()]     #ravel，可以把二维矩阵平铺成一维数组
```

## 18、c_

### 功能

np.c_ 的核心功能是将多个数组（通常是一维或二维）沿着**第二个轴（列方向）**拼接，生成一个新的二维数组。每个输入数组被视为一列（或多列），拼接后形成一个矩阵。

- **输入**：多个 NumPy 数组（可以是一维或二维，形状需兼容）。
- **输出**：一个二维数组，列数是所有输入数组列数的总和，行数由输入数组的行数决定。

np.c_ 是 NumPy 索引表达式的简写，等价于使用 np.concatenate 或 np.hstack，但更简洁，专为列拼接设计。

------

### 用法

np.c_ 的基本语法如下：

```
import numpy as np result = np.c_[array1, array2, ..., arrayN]
```

- 参数：
  - array1, array2, ..., arrayN：要拼接的数组，可以是一维或二维。
  - 要求所有数组的**行数**（或一维数组的长度）相同，否则会抛出错误。
  - 如果输入是一维数组，会先将其转换为二维列向量（形状 (n, 1)）。
- 返回：
  - 一个二维数组，形状为 (n, m1 + m2 + ... + mN)，其中：
    - n 是输入数组的行数（或一维数组的长度）。
    - m1, m2, ..., mN 是每个输入数组的列数。



## 19、  ravel  和  flatten  对比

在 NumPy 中，`ravel()` 和 `flatten()` 是两个用于将多维数组展平为一维数组的方法。尽管它们的功能看起来类似（都返回一维数组），但在实现细节、性能和行为上存在一些关键差异。以下是对 `ravel()` 和 `flatten()` 的纯讲解，专注于它们的定义、用法、区别和应用场景。

---

### 1. **`ravel()`**

#### 定义

`ravel()` 是 NumPy 数组的一个方法，返回数组的展平视图（flattened view），即将多维数组转换为一维数组。它尽量返回原数组的视图（view），而不是复制数据，从而节省内存。

#### 用法

```python
import numpy as np
array.ravel(order='C')
```

- **参数**：
  - `order`：展平的顺序，默认为 `'C'`（按行优先，C 风格）。
    - `'C'`：按行展平（默认）。
    - `'F'`：按列展平（Fortran 风格）。
    - `'A'`：根据内存布局选择 `'C'` 或 `'F'`。
    - `'K'`：尽量按原始内存顺序。

- **返回**：
  - 一维数组（视图或复制，取决于输入数组的内存布局）。
  - 如果原数组是连续的（contiguous），返回视图；如果不是，可能返回复制。

#### 示例

```python
import numpy as np

# 二维数组
a = np.array([[1, 2, 3],
              [4, 5, 6]])

# 使用 ravel
b = a.ravel()
print("ravel 结果:", b)
print("形状:", b.shape)

# 修改 b 的值
b[0] = 99
print("修改后的原数组 a:\n", a)
```

**输出**：

```
ravel 结果: [1 2 3 4 5 6]
形状: (6,)
修改后的原数组 a:
 [[99  2  3]
  [ 4  5  6]]
```

- **解释**：
  - `a` 是 `(2, 3)` 的二维数组，`ravel()` 将其展平为长度 6 的一维数组。
  - `b` 是 `a` 的视图，修改 `b` 会影响原数组 `a`（因为是视图）。
  - 展平顺序是按行（`order='C'`）：`[1, 2, 3, 4, 5, 6]`。

#### 特点

- **视图优先**：尽量返回原数组的视图，修改结果会影响原数组。
- **内存效率**：如果返回视图，不复制数据，节省内存。
- **适用场景**：需要展平数组且允许修改原数组，或追求性能时。

---

### 2. **`flatten()`**

#### 定义

`flatten()` 是 NumPy 数组的一个方法，返回数组的展平复制（flattened copy），即将多维数组转换为一维数组。它总是返回数据的独立副本，修改结果不会影响原数组。

#### 用法

```python
import numpy as np
array.flatten(order='C')
```

- **参数**：
  - `order`：展平顺序，与 `ravel()` 相同：
    - `'C'`：按行展平（默认）。
    - `'F'`：按列展平。
    - `'A'`：根据内存布局。
    - `'K'`：按内存顺序。

- **返回**：
  - 一维数组，总是原数组的复制（copy）。

#### 示例

```python
import numpy as np

# 二维数组
a = np.array([[1, 2, 3],
              [4, 5, 6]])

# 使用 flatten
b = a.flatten()
print("flatten 结果:", b)
print("形状:", b.shape)

# 修改 b 的值
b[0] = 99
print("修改后的原数组 a:\n", a)
```

**输出**：

```
flatten 结果: [1 2 3 4 5 6]
形状: (6,)
修改后的原数组 a:
 [[1 2 3]
  [4 5 6]]
```

- **解释**：
  - `a` 是 `(2, 3)` 的二维数组，`flatten()` 将其展平为长度 6 的一维数组。
  - `b` 是 `a` 的复制，修改 `b` 不影响原数组 `a`。
  - 展平顺序是按行（`order='C'`）：`[1, 2, 3, 4, 5, 6]`。

#### 特点

- **复制优先**：总是返回原数组的复制，修改结果不影响原数组。
- **内存开销**：需要分配新内存，复制数据，内存使用较多。
- **适用场景**：需要展平数组且不希望影响原数组，或需要独立操作。

---

### `ravel()` vs. `flatten()`：关键区别

| 特性         | `ravel()`                            | `flatten()`                |
| ------------ | ------------------------------------ | -------------------------- |
| **返回类型** | 视图（优先），可能复制               | 总是复制                   |
| **修改影响** | 修改结果通常影响原数组（如果是视图） | 修改结果不影响原数组       |
| **内存效率** | 高（视图不复制数据）                 | 低（总是复制数据）         |
| **性能**     | 更快（避免复制）                     | 稍慢（需要复制）           |
| **方法来源** | NumPy 数组方法                       | NumPy 数组方法             |
| **参数**     | `order`（C, F, A, K）                | `order`（C, F, A, K）      |
| **适用场景** | 性能敏感、允许修改原数组             | 需要独立副本、不影响原数组 |

---

### 更详细的比较

1. **视图与复制**：

   - `ravel()`：

     - 如果原数组是连续存储（C 风格或 Fortran 风格），`ravel()` 返回视图。

     - 如果原数组非连续（例如切片或转置后的数组），可能返回复制。

     - 示例（非连续数组）：

       ```python
       a = np.array([[1, 2], [3, 4]])
       b = a[:, 0]  # 非连续
       c = b.ravel()
       c[0] = 99
       print("b:", b)  # 未改变，因为 c 是复制
       ```

   - `flatten()`：

     - 总是返回复制，无论数组是否连续。

     - 示例：

       ```python
       a = np.array([[1, 2], [3, 4]])
       b = a.flatten()
       b[0] = 99
       print("a:", a)  # 未改变
       ```

2. **性能差异**：

   - `ravel()` 通常更快，因为视图操作只需调整数组的元数据（strides），而不需要复制数据。

   - `flatten()` 需要分配新内存并复制所有元素，耗时更多，尤其在大数组上。

   - 示例（性能测试）：

     ```python
     import numpy as np
     import time
     
     a = np.random.rand(1000, 1000)
     start = time.time()
     for _ in range(1000):
         a.ravel()
     print("ravel 时间:", time.time() - start)
     
     start = time.time()
     for _ in range(1000):
         a.flatten()
     print("flatten 时间:", time.time() - start)
     ```

     - `ravel()` 通常比 `flatten()` 快数倍。

3. **内存使用**：

   - `ravel()`：视图只引用原数组数据，内存开销极小。
   - `flatten()`：复制数据需要额外内存，等于原数组大小。
   - 对于大数组（例如 1GB），`flatten()` 可能导致内存不足，而 `ravel()` 更安全。

4. **展平顺序**：

   - 两者都支持 `order` 参数，控制展平方式。

   - 示例（按列展平）：

     ```python
     a = np.array([[1, 2], [3, 4]])
     print(a.ravel(order='F'))   # [1, 3, 2, 4]
     print(a.flatten(order='F')) # [1, 3, 2, 4]
     ```

---

### 常见用途

1. **展平多维数组**：

   - 将高维数组（如矩阵或张量）转换为一维，用于后续计算。

   - 示例：

     ```python
     a = np.array([[1, 2], [3, 4]])
     flat = a.ravel()  # [1, 2, 3, 4]
     ```

2. **机器学习输入**：

   - 将网格坐标或其他多维数据展平，输入模型。

   - 示例：

     ```python
     x, y = np.meshgrid([1, 2], [3, 4])
     points = np.c_[x.ravel(), y.ravel()]  # 坐标点
     ```

3. **数据处理**：

   - 展平后进行统计计算（如均值、排序）。

   - 示例：

     ```python
     a = np.array([[1, 2], [3, 4]])
     mean = a.ravel().mean()  # 2.5
     ```

4. **可视化**：

   - 配合 `meshgrid`，展平网格点以计算函数值或绘制图形。

   - 示例：

     ```python
     x, y = np.meshgrid(np.linspace(-1, 1, 3), np.linspace(-1, 1, 3))
     z = (x.ravel()**2 + y.ravel()**2).reshape(x.shape)
     ```

---

### 注意事项

1. **选择依据**：

   - 用 `ravel()`：当性能和内存是优先考虑，且允许修改原数组。
   - 用 `flatten()`：当需要独立副本，或不希望影响原数组。

2. **视图的潜在风险**：

   - `ravel()` 返回视图时，修改结果会改变原数组，可能导致意外后果。

   - 示例：

     ```python
     a = np.array([[1, 2], [3, 4]])
     b = a.ravel()
     b[0] = 99  # a 变为 [[99, 2], [3, 4]]
     ```

3. **替代方法**：

   - `np.ravel(array)`：全局函数，类似 `array.ravel()`，但可直接应用于非数组对象。

   - `array.flat`：返回迭代器，适合逐元素访问。

   - `array.reshape(-1)`：功能类似 `ravel()`，但语法不同。

   - 示例：

     ```python
     a = np.array([[1, 2], [3, 4]])
     print(np.ravel(a))       # [1, 2, 3, 4]
     print(a.reshape(-1))     # [1, 2, 3, 4]
     ```

4. **非连续数组**：

   - 对于切片或转置数组，`ravel()` 可能返回复制（而非视图）。

   - 示例：

     ```python
     a = np.array([[1, 2], [3, 4]])
     b = a.T  # 转置，非连续
     c = b.ravel()
     c[0] = 99  # 不影响 a
     ```

---

### 总结

- **`ravel()`**：
  - 返回展平的视图（优先），修改可能影响原数组。
  - 内存高效，性能快。
  - 适合性能敏感场景。
- **`flatten()`**：
  - 返回展平的复制，修改不影响原数组。
  - 内存开销大，性能稍慢。
  - 适合需要独立副本的场景。
- **共同点**：
  - 将多维数组展平为一维。
  - 支持 `order` 参数（C, F, A, K）。
- **用途**：
  - 数据展平、模型输入、可视化、统计计算。

如果你对 `ravel()` 或 `flatten()` 的某个细节有疑问（比如内存管理、性能测试或高级用法），告诉我，我可以进一步讲解！

## 20、numpt.sum函数

`np.sum` 是 NumPy 库中的一个函数，用于计算数组元素的总和。它非常灵活，支持多维数组、指定轴、数据类型控制等功能，是科学计算中常用的工具。以下是对 `np.sum` 的纯讲解，专注于其功能、参数、使用场景和输出效果。

---

### 功能

`np.sum` 计算给定数组中所有元素或沿指定轴的元素之和，返回一个标量（对整个数组）或数组（沿轴求和）。

- **输入**：NumPy 数组或其他类似数组的对象。
- **输出**：总和（标量或数组），数据类型可控。
- **用途**：统计、矩阵运算、数据处理等。

---

### 用法

基本语法：

```python
import numpy as np
np.sum(a, axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)
```

- **参数**：
  - **`a`**：
    - 输入数组，必需参数。
    - 可以是 NumPy 数组、列表或其他可转换为数组的对象。
  - **`axis`**：
    - 指定沿哪个轴求和，默认为 `None`。
    - `None`：对整个数组展平后求和，返回标量。
    - 整数或元组：沿指定轴（或多个轴）求和，返回数组。
  - **`dtype`**：
    - 输出和的精确数据类型，默认为输入数组类型或推导类型。
    - 示例：`np.float64`, `np.int32`。
  - **`out`**：
    - 可选的输出数组，用于存储结果（需形状匹配）。
    - 默认 `None`，返回新数组。
  - **`keepdims`**：
    - 布尔值，默认为 `False`。
    - `True`：保留被求和轴的维度（长度为 1）。
    - `False`：移除被求和轴。
  - **`initial`**：
    - 求和的起始值，默认为 0。
    - 影响结果：`sum = initial + elements_sum`。
  - **`where`**：
    - 布尔数组，指定哪些元素参与求和。
    - 默认 `True`，包含所有元素。

- **返回**：
  - 标量（`axis=None` 时）或数组（沿轴求和时）。
  - 数据类型由 `dtype` 或输入数组决定。

---

### 工作原理

- **整体求和**：
  - 当 `axis=None` 时，`np.sum` 将数组展平为一维，然后计算所有元素之和。
  - 示例：`[[1, 2], [3, 4]]` 展平为 `[1, 2, 3, 4]`，和为 `10`。

- **按轴求和**：
  - 当指定 `axis` 时，沿该轴计算每个子数组的和。
  - 轴是数组的维度：
    - `axis=0`：沿行方向（跨行），对每列求和。
    - `axis=1`：沿列方向（跨列），对每行求和。
  - 输出形状移除被求和的轴（除非 `keepdims=True`）。

- **灵活性**：
  - 支持多维数组、条件求和（`where`）、自定义类型（`dtype`）。

---

### 示例

#### 示例 1：整体求和

```python
import numpy as np

a = np.array([[1, 2], [3, 4]])
result = np.sum(a)
print("Sum:", result)
```

**输出**：

```
Sum: 10
```

- **解释**：
  - `a` 是 `(2, 2)` 数组，展平为 `[1, 2, 3, 4]`。
  - `np.sum(a)` 计算 `1 + 2 + 3 + 4 = 10`，返回标量。

#### 示例 2：按轴求和

```python
a = np.array([[1, 2], [3, 4]])
sum_axis0 = np.sum(a, axis=0)
sum_axis1 = np.sum(a, axis=1)
print("Sum along axis 0:", sum_axis0)
print("Sum along axis 1:", sum_axis1)
```

**输出**：

```
Sum along axis 0: [4 6]
Sum along axis 1: [3 7]
```

- **解释**：

  - `a`：

    ```python
    [[1, 2],
     [3, 4]]
    ```

  - `axis=0`（跨行，对每列求和）：

    - 第 1 列：`1 + 3 = 4`。
    - 第 2 列：`2 + 4 = 6`。
    - 结果：`[4, 6]`，形状 `(2,)`。

  - `axis=1`（跨列，对每行求和）：

    - 第 1 行：`1 + 2 = 3`。
    - 第 2 行：`3 + 4 = 7`。
    - 结果：`[3, 7]`，形状 `(2,)`。

#### 示例 3：保留维度

```python
a = np.array([[1, 2], [3, 4]])
result = np.sum(a, axis=0, keepdims=True)
print("Sum with keepdims:", result)
print("Shape:", result.shape)
```

**输出**：

```
Sum with keepdims: [[4 6]]
Shape: (1, 2)
```

- **解释**：
  - `axis=0`：对每列求和，`[4, 6]`。
  - `keepdims=True`：保留轴 0，输出形状 `(1, 2)` 而不是 `(2,)`。
  - 结果是 `[[4, 6]]`，便于广播或后续操作。

#### 示例 4：指定数据类型

```python
a = np.array([1.5, 2.5])
result = np.sum(a, dtype=np.int32)
print("Sum with int32:", result)
```

**输出**：

```
Sum with int32: 4
```

- **解释**：
  - `a` 是浮点数组，`1.5 + 2.5 = 4.0`。
  - `dtype=np.int32`：强制结果为整数，`4.0` 转换为 `4`。

#### 示例 5：条件求和

```python
a = np.array([1, 2, 3, 4])
result = np.sum(a, where=a > 2)
print("Sum where a > 2:", result)
```

**输出**：

```
Sum where a > 2: 7
```

- **解释**：
  - `where=a > 2`：只对满足条件的元素求和。
  - `a > 2`：`[False, False, True, True]`。
  - 求和：`3 + 4 = 7`。

#### 示例 6：初始值

```python
a = np.array([1, 2])
result = np.sum(a, initial=10)
print("Sum with initial=10:", result)
```

**输出**：

```
Sum with initial=10: 13
```

- **解释**：
  - 数组和：`1 + 2 = 3`。
  - 加初始值：`3 + 10 = 13`。

---

### 常见用途

1. **统计计算**：
   - 计算数组总和、均值（结合 `np.mean`）、方差等。
   - 示例：`np.sum(data)` 计算数据集总和。

2. **矩阵运算**：
   - 按行或列求和，简化矩阵操作。
   - 示例：`np.sum(matrix, axis=1)` 计算每行和。

3. **机器学习**：
   - 计算损失函数、距离（如欧几里得距离）。
   - 示例：`np.sum((x - y)**2)` 计算平方误差。

4. **数据处理**：
   - 条件求和，过滤无效值。
   - 示例：`np.sum(data, where=data > 0)` 计算正值和。

5. **多维数组操作**：
   - 沿指定轴汇总数据，降维处理。
   - 示例：`np.sum(tensor, axis=(1, 2))` 降维求和。

---

### 注意事项

1. **轴的选择**：

   - `axis` 从 0 开始，需匹配数组维度。

   - 错误示例：

     ```python
     a = np.array([[1, 2]])
     np.sum(a, axis=2)  # 错误：轴超出范围
     ```

2. **数据类型**：

   - 默认 `dtype` 可能导致精度问题（如整数溢出）。

   - 示例：

     ```python
     a = np.array([2**31, 1])
     print(np.sum(a, dtype=np.int32))  # 溢出
     print(np.sum(a, dtype=np.int64))  # 正确
     ```

3. **空数组**：

   - 空数组求和返回 `initial` 值（默认 0）。

   - 示例：

     ```python
     np.sum([], initial=5)  # 返回 5
     ```

4. **性能**：

   - `np.sum` 比 Python 内置 `sum` 快，尤其在大数组上。

   - 示例：

     ```python
     a = np.random.rand(1000000)
     %timeit np.sum(a)  # 更快
     %timeit sum(a)     # 较慢
     ```

5. **与 np.add.reduce 的关系**：

   - `np.sum` 等价于 `np.add.reduce`：

     ```python
     np.sum(a) == np.add.reduce(a)
     ```

   - 但 `np.sum` 更直观，参数更丰富。

6. **多轴求和**：

   - 支持元组形式：

     ```python
     a = np.ones((2, 3, 4))
     np.sum(a, axis=(1, 2))  # 形状 (2,)
     ```

---

### 总结

- **功能**：
  - `np.sum` 计算数组元素总和，支持整体或按轴求和。
- **关键参数**：
  - `a`：输入数组。
  - `axis`：求和轴（`None`, 整数或元组）。
  - `dtype`：输出类型。
  - `keepdims`：保留维度。
  - `where`：条件求和。
  - `initial`：起始值。
- **输出**：
  - 标量（整体求和）或数组（按轴求和）。
- **用途**：
  - 统计、矩阵运算、机器学习、数据处理。
- **特点**：
  - 高效、灵活，支持多维数组和条件操作。

如果你对 `np.sum` 的某个细节有疑问（比如性能优化、轴操作或特殊用例），告诉我，我可以进一步讲解！

# 2、pandas包

------

`pandas` 是 Python 中一个强大的数据分析库，广泛应用于数据清洗、分析、可视化和建模。它提供了 **DataFrame** 和 **Series** 两种核心数据结构，使得处理和分析表格数据变得简单而高效。下面是一些 `pandas` 的常用知识和操作：

### 1. **安装 pandas**

首先确保你已安装了 `pandas`，可以通过以下命令安装：

```bash
pip install pandas
```

### 2. **导入 pandas**

通常，我们使用 `pd` 来作为 `pandas` 的别名：

```python
import pandas as pd
```

### 3. **pandas 核心数据结构**

- **Series**：一维数据结构，类似于 Python 的列表或数组。

- **Data Frame**：二维数据结构，类似于数据库中的表格、Excel 工作表，或 R 中的`data.frame`。

- **切片 `a:b` 总是按行操作**，相当于 `.iloc[a:b]`。

  **单个索引 `x` 默认按列标签取列**。

#### 创建 Series  

```python
# 使用列表创建 Series
s = pd.Series([1, 2, 3, 4, 5])
print(s)
```

#### 创建 Data Frame

```python
# 使用字典创建 DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [24, 27, 22], 'City': ['NY', 'LA', 'SF']}
df = pd.DataFrame(data,index=?,columns=?)
print(df)
```

### 4. **基本操作**

#### 查看数据

```python
# 查看 DataFrame 的前几行
print(df.head())  # 默认查看前 5 行

# 查看 DataFrame 的后几行
print(df.tail())

# 查看 DataFrame 的基本信息（列数、非空值等）
print(df.info())

# 查看数据的基本统计信息
print(df.describe())

#属性不需要括号,方法才需要
print(df.dtypes)#df的类型
print(df.index)#df的行标签
print(df.columns)#df的列标签
print(df.values)#df的值,可以转换为numpy矩阵
print(df.describe())#df的数值情况比如方差、平均值等等，编译器会忽略非数值数据,需要注意的是，describe是一个方法而非属性
print(df.T) #同样可以进行转置
```

#### 获取列

```python
# 获取单独的列
print(df['Name'])

# 使用属性方式获取列
print(df.Name)
```

#### 获取行

```python
# 通过索引获取单行
print(df.iloc[0])  # 获取第 1 行（按位置）

# 通过标签获取单行
print(df.loc[0])  # 获取第 1 行（按标签），pandas的切片操作是左闭右闭
print(df2.loc[0:2,['A','C']])
# 获取多个行
print(df.iloc[0:2])  # 获取前两行
print(df.iloc[1:2,2:3]) # 获取12行23列
print(df.iloc[1,2]) #iloc方法是通过位置索引查找
#增加一列
print(df['F']=np.nan)
```

#### 设置索引

```python
# 将列设置为索引
df.set_index('Name', inplace=True)
print(df)
```

#### 重置索引

```python
# 重置索引
df.reset_index(inplace=True)
print(df)
```

### 5. **数据选择与过滤**

#### 条件筛选

```python
# 选择符合条件的行
df_filtered = df[df['Age'] > 24]
print(df_filtered)
print(df.Age[df['Age']>24])
print(df.NUM[df['Age']>24])


```

#### 在 Pandas 中，可以用布尔数组筛选 Series 或 DataFrame 的行。

`data [x_axis][data['class']== iris_type] `提取 petal_length 中对应于 iris_type 类别的值。

#### 选择特定的列

```python
# 选择特定的列
print(df[['Name', 'Age']])
```

#### 使用多个条件筛选

```python
# 使用 & (and) 或 | (or) 进行多条件筛选
df_filtered = df[(df['Age'] > 24) & (df['City'] == 'NY')]
print(df_filtered)
```

### 6. **缺失数据处理**

#### 检查缺失数据

```python
# 检查是否有缺失值
print(df.isnull())  # 返回一个布尔值的 DataFrame

# 检查每列缺失数据的总数
print(df.isnull().sum())
```

#### 填充缺失值

```python
# 使用特定值填充缺失值
df.fillna(0, inplace=True)

# 使用前一个值填充缺失值
df.fillna(method='ffill', inplace=True)

# 使用后一个值填充缺失值
df.fillna(method='bfill', inplace=True)
```

#### 删除缺失数据

```python
# 删除包含缺失数据的行
df.dropna(inplace=True)
#需要注意是的，dropna方法并非直接删除，而是给你隐藏掉了，因此我们需要有一个新的变量去接收返回值
# 删除包含缺失数据的列
df.dropna(axis=1, inplace=True)
```

### 7. **数据清洗与处理**

#### 重命名列

```python
# 重命名列
df.rename(columns={'Age': 'Age (Years)'}, inplace=True)
```

#### 合并与连接

- **合并（Merge）**：类似 SQL 中的 `JOIN` 操作。

```python
df1 = pd.DataFrame({'ID': [1, 2, 3], 'Name': ['Alice', 'Bob', 'Charlie']})
df2 = pd.DataFrame({'ID': [2, 3, 4], 'Age': [24, 27, 22]})

# 按 'ID' 列合并
merged_df = pd.merge(df1, df2, on='ID', how='inner')  # 'inner' 表示内连接
print(merged_df)
```

- **连接（Concat）**：按行或列连接多个 DataFrame。

```python
# 按行连接
df_concat = pd.concat([df1, df2], axis=0)
df_concat = pd.concat([df1, df2], axis=0，ignore_idnex=True)#忽略原有序列的索引
print(df_concat)

# 按列连接
df_concat = pd.concat([df1, df2], axis=1)
print(df_concat)
```

### 8. **排序与排名**

#### 排序

```python
# 按照列排序
df.sort_values(by='Age', ascending=False, inplace=True)

# 按多个列排序
df.sort_values(by=['Age', 'Name'], ascending=[False, True], inplace=True)
```

#### 排名

```python
# 按列计算排名
df['Age Rank'] = df['Age'].rank(ascending=False)
print(df)
```

### 9. **分组操作（GroupBy）**

#### 分组并聚合

```python
# 根据某一列进行分组，并计算每组的统计信息
df_grouped = df.groupby('City')['Age'].mean()
print(df_grouped)
```

#### 多重聚合

```python
# 对每一组应用多个聚合函数
df_grouped = df.groupby('City').agg({'Age': ['mean', 'max', 'min']})
print(df_grouped)
```

### 10. **数据透视表（Pivot Table）**

```python
# 创建数据透视表
pivot_df = df.pivot_table(values='Age', index='City', aggfunc='mean')
print(pivot_df)
```

### 11. **时间序列**

#### 转换为日期时间格式

```python
# 将列转换为日期时间格式
df['Date'] = pd.to_datetime(df['Date'])
```

#### 生成时间序列

```python
# 生成日期范围
date_range = pd.date_range('2023-01-01', periods=5, freq='D')
print(date_range)
```

#### 时间切片

```python
# 设置时间列为索引
df.set_index('Date', inplace=True)

# 选择某个时间范围的数据
df_filtered = df['2023-01-01':'2023-01-03']
print(df_filtered)
```

### 12. **文件读取与写入**

#### 1、读取 CSV 文件

```python
# 从 CSV 文件读取数据
df = pd.read_csv('data.csv')

# 从 Excel 文件读取数据
df = pd.read_excel('data.xlsx', sheet_name='Sheet1')
```

#### 2、写入文件

```python
# 将 DataFrame 写入 CSV 文件
df.to_csv('output.csv', index=False)

# 将 DataFrame 写入 Excel 文件
df.to_excel('output.xlsx', index=False)
```

==以下是用 pandas 读取和保存 pickle 及 CSV 文件的语法，不含示例：==

- **读取 pickle 文件**

```python
pd.read_pickle('文件路径.pkl')
```

- **读取 CSV 文件**

```python
pd.read_csv('文件路径.csv', encoding='utf-8')
```

#### 3、保存文件

- **保存为 pickle 文件**

```python
DataFrame.to_pickle('输出路径.pkl', compression='infer', protocol=5)
```

- **保存为 CSV 文件**

```python
DataFrame.to_csv('输出路径.csv', index=False, encoding='utf-8')
```





## 13.sort_index 和 sort_values

 在 Pandas 中，`sort_index` 和 `sort_values` 是两个常用的方法，用于对 Data Frame 或 Series 进行排序。它们的功能和用法有所不同，下面我详细解释一下：

---

### 1. `sort_index`

- **作用**：按照索引（index）对 Data Frame 或 Series 进行排序。
- **适用于**：当你想基于行索引或列索引重新排列数据时。

#### 语法

```python
DataFrame.sort_index(axis=0, ascending=True, inplace=False, ...)
Series.sort_index(ascending=True, inplace=False, ...)
```

- **`axis`**：排序的轴，`0` 表示按行索引排序（默认），`1` 表示按列索引排序。
- **`ascending`**：是否升序排序，`True`（默认）为升序，`False` 为降序。
- **`inplace`**：是否修改原数据，`False`（默认）返回新对象，`True` 修改原对象。

#### 示例

```python
import pandas as pd

# 创建一个 DataFrame
df = pd.DataFrame({
    "A": [1, 3, 2],
    "B": [4, 6, 5]
}, index=[2, 0, 1])

print("原始 DataFrame:")
print(df)

# 按行索引排序
print("\n按行索引排序:")
print(df.sort_index())

# 按列索引排序
print("\n按列索引排序:")
print(df.sort_index(axis=1))
```

输出：

```
原始 DataFrame:
   A  B
2  1  4
0  3  6
1  2  5

按行索引排序:
   A  B
0  3  6
1  2  5
2  1  4

按列索引排序:
   A  B
2  1  4
0  3  6
1  2  5
```

- **解释**：`sort_index()` 按索引 `[2, 0, 1]` 重新排序为 `[0, 1, 2]`，列顺序不变。`axis=1` 时按列名排序（这里 `A` 和 `B` 已按字母顺序排列，所以不变）。

---

### 2. `sort_values`

- **作用**：按照某一列或多列的值（value）对 Data Frame 或 Series 进行排序。
- **适用于**：当你想基于数据内容排序时。

#### 语法

```python
DataFrame.sort_values(by, axis=0, ascending=True, inplace=False, ...)
Series.sort_values(ascending=True, inplace=False, ...)
```

- **`by`**：指定排序的列名（对 Data Frame）或列名列表。可以是字符串或字符串列表。
- **`axis`**：排序轴，`0`（默认）按列值排序，`1` 按行值排序。
- **`ascending`**：是否升序，`True`（默认）为升序，`False` 为降序。
- **`inplace`**：是否修改原数据。

#### 示例

```python
import pandas as pd

# 创建一个 DataFrame
df = pd.DataFrame({
    "A": [3, 1, 2],
    "B": [6, 4, 5]
}, index=[0, 1, 2])

print("原始 DataFrame:")
print(df)

# 按 A 列排序
print("\n按 A 列排序:")
print(df.sort_values(by="A"))

# 按 B 列降序排序
print("\n按 B 列降序排序:")
print(df.sort_values(by="B", ascending=False))

# 按多列排序
print("\n按 A 和 B 排序:")
print(df.sort_values(by=["A", "B"]))
```

输出：

```
原始 DataFrame:
   A  B
0  3  6
1  1  4
2  2  5

按 A 列排序:
   A  B
1  1  4
2  2  5
0  3  6

按 B 列降序排序:
   A  B
0  3  6
2  2  5
1  1  4

按 A 和 B 排序:
   A  B
1  1  4
2  2  5
0  3  6
```

- **解释**：
  - `by="A"`：按 `A` 列值升序排列。
  - `by="B", ascending=False`：按 `B` 列值降序排列。
  - `by=["A", "B"]`：先按 `A` 排序，`A` 相同时再按 `B` 排序。

---

### 主要区别

| 特性         | `sort_index`       | `sort_values`      |
| ------------ | ------------------ | ------------------ |
| **排序依据** | 索引（index）      | 数据值（values）   |
| **参数**     | 无需指定列名       | 需要 `by` 指定列名 |
| **适用场景** | 调整索引顺序       | 按内容排序         |
| **默认轴**   | `axis=0`（行索引） | `axis=0`（按列值） |

---

### 注意事项

1. **缺失值（Nan）**：

   - 默认情况下，`NaN` 会被排到最后，可以用 `na_position="first"` 将其排到开头。

   ```python
   df = pd.DataFrame({"A": [1, None, 3]})
   print(df.sort_values(by="A", na_position="first"))
   ```

   输出：

   ```
      A
   1  NaN
   0  1.0
   2  3.0
   ```

2. **Series vs Data Frame**：

   - Series 只有一列数据，`sort_index` 和 `sort_values` 直接作用于索引或值。
   - Data Frame 需要指定 `by`（`sort_values`）或 `axis`。

3. **性能**：

   - 对于大数据集，排序可能是耗时操作，尤其是多列排序。

如果你有具体代码或数据想用这两个方法处理，可以给我看，我帮你分析和实现！

### 小结

- **基本操作**：`head()`, `tail()`, `info()`, `describe()` 等方法帮助你快速了解数据。
- **选择和筛选**：使用 `.loc[]`, `.iloc[]`, 条件筛选来提取数据。
- **缺失值处理**：使用 `isnull()`, `fillna()`, `dropna()` 等方法处理缺失值。
- **合并和连接**：`merge()`, `concat()` 等方法可以帮助你合并多个数据集。
- **分组和聚合**：`groupby()` 和 `pivot_table()` 可以对数据进行分组、聚合和透视。
- **时间序列**：`pd.to_datetime()`, `pd.date_range()` 等方法帮助你处理时间数据。

掌握了这些基本操作，你就能高效地使用 `pandas` 进行数据分析、清洗和处理了。

## 14.dropna方法

在 pandas 中，`dropna()` 是一个非常实用的方法，用于处理 DataFrame 或 Series 中的缺失值（NaN）。让我为你详细解释一下它的用法：

### 基本用法

`dropna()` 会删除包含缺失值的行或列，默认情况下是删除任何包含 NaN 的行。

#### 语法

```python
DataFrame.dropna(axis=0, how='any', thresh=None, subset=None, inplace=False)
```

#### 参数说明

1. **`axis`**:
   - `0` 或 `'index'`：删除包含 NaN 的行（默认）。
   - `1` 或 `'columns'`：删除包含 NaN 的列。

2. **`how`**:
   - `'any'`：只要有 NaN 就删除该行或列（默认）。
   - `'all'`：只有当整行或整列都是 NaN 时才删除。

3. **`thresh`**:
   - 指定一个整数，表示至少需要多少个非 NaN 值才能保留该行或列。

4. **`subset`**:
   - 指定特定的列或行标签，只在这些子集中检查 NaN。

5. **`inplace`**:
   - `False`：返回新的 DataFrame，原数据不变（默认）。
   - `True`：直接修改原 DataFrame。

### 示例

假设你有以下 DataFrame：

```python
import pandas as pd

data = {'A': [1, 2, None], 'B': [4, None, 6], 'C': [7, 8, 9]}
df = pd.DataFrame(data)
print(df)
```

输出：

```
     A    B  C
0  1.0  4.0  7
1  2.0  NaN  8
2  NaN  6.0  9
```

#### 1. 默认删除包含 NaN 的行

```python
df.dropna()
```

输出：

```
     A    B  C
0  1.0  4.0  7
```

#### 2. 删除包含 NaN 的列

```python
df.dropna(axis=1)
```

输出：

```
   C
0  7
1  8
2  9
```

#### 3. 只删除全为 NaN 的行

```python
df.dropna(how='all')
```

输出：

```
     A    B  C
0  1.0  4.0  7
1  2.0  NaN  8
2  NaN  6.0  9
```

#### 4. 指定子集

```python
df.dropna(subset=['A'])
```

输出：

```
     A    B  C
0  1.0  4.0  7
1  2.0  NaN  8
```

注意事项

- 如果数据中有大量缺失值，使用 `dropna()` 可能会导致数据丢失较多，可以考虑用 `fillna()` 填充缺失值作为替代方案。
- 你可以用 `df.isna()` 或 `df.isnull()` 检查缺失值的位置。

如果你有具体的 pandas 数据问题或代码需要帮助，随时告诉我，我可以用中文详细解答！

## 15、contact方法

以下是用 pandas 进行连接（concatenation）的 `concat()` 函数语法，用于合并多个 DataFrame 或 Series，不含示例：

### `pandas.concat()` 语法

```python
pd.concat(objs, axis=0, join='outer', ignore_index=False, keys=None, levels=None, names=None, verify_integrity=False, sort=False, copy=True)
```

#### 参数说明

- **`objs`**：要合并的对象列表或字典（如 `[df1, df2 ]`）。
- **`axis`**：合并方向，`0`（按行，垂直堆叠）或 `1`（按列，水平拼接）。
- **`join`**：合并方式，`'outer'`（并集）或 `'inner'`（交集）。
- **`ignore_index`**：是否重置索引，`True` 或 `False`。
- **`keys`**：为合并结果添加层次索引（如 `[‘group1’, ‘group2’]`）。
- **`verify_integrity`**：检查索引是否重复，`True` 时若重复则报错。
- **`sort`**：对非合并轴排序，`True` 或 `False`。
- **`copy`**：是否复制数据，`True` 或 `False`。

### 注意

- 需要导入 pandas：`import pandas as pd`。
- 可用于 DataFrame 或 Series。

## 16、merge方法

```python
merged_df = pd.merge(df1, df2, on='key_column', how='inner')
```

### 参数说明

- **df1, df2**: 要合并的两个数据框。
- **on**: 合并时使用的共同列名（键）。
- **how**: 合并方式，可选：
  -  `'inner'`: 内连接，仅保留键匹配的行。
  -  `'outer'`: 外连接，保留所有行，未匹配处填 NaN。
  -  `'left'`: 左连接，保留左数据框所有行。
  -  `'right'`: 右连接，保留右数据框所有行。
- 是的，pandas 的 `merge` 函数还有其他参数。

  - **left_on**: 左数据框中用作键的列名（当左右键名不同时使用）。
  - **right_on**: 右数据框中用作键的列名（当左右键名不同时使用）。
  - **left_index**: 如果为 True，用左数据框的索引作为键。
  - **right_index**: 如果为 True，用右数据框的索引作为键。
  - **suffixes**: 当两数据框有相同列名时，添加的后缀，默认是 `('_x', '_y')`。 
  - **indicator**: 如果为 True，添加一列 `_merge`，显示每行数据的来源（`left_only`, `right_only`, `both`）。
  - **validate**: 检查合并的键是否符合预期关系，可选值包括：
    - `'one_to_one'`: 一对一。
    - `'one_to_many'`: 一对多。
    - `'many_to_one'`: 多对一。
    - `'many_to_many'`: 多对多。

# 3、matplotlib

Matplotlib 是 Python 中最常用的可视化库，提供了丰富的函数和功能，用于创建各种类型的图表，包括折线图、散点图、柱状图、等高线图等。以下是 Matplotlib 常用的函数和功能的整理，专注于核心绘图工具、图形设置和常见用途，保持清晰简洁。

---

### 1. 基本绘图函数

这些函数用于创建主要图形类型。

- **`plt.plot(x, y, fmt, **kwargs)`**

  - **功能**：绘制折线图或散点图（取决于格式字符串 `fmt`）。

  - **用途**：展示连续数据趋势或点分布。

  - **参数**：

    - `x, y`：x 和 y 坐标。
    - `fmt`：样式，如 `'b-'`（蓝色实线）、`'ro'`（红色圆点）。
    - `markersize`, `linewidth`, `color` 等。

  - **示例**：

    ```python
    plt.plot([1, 2, 3], [4, 5, 6], 'b--', linewidth=2)
    ```

- **`plt.scatter(x, y, s=None, c=None, marker=None, **kwargs)`**

  - **功能**：绘制散点图，支持动态大小和颜色。

  - **用途**：展示数据点分布，分类或聚类可视化。

  - **参数**：

    - `s`：点大小（标量或数组）。
    - `c`：颜色（标量、数组或颜色名称）。
    - `marker`：标记形状（如 `'o'`, `'x'`）。
    - `alpha`：透明度。

  - **示例**：

    ```python
    plt.scatter(x, y, s=50, c='red', alpha=0.5)
    ```

- **`plt.bar(x, height, width=0.8, **kwargs)`**

  - **功能**：绘制柱状图。

  - **用途**：比较类别数据或统计结果。

  - **参数**：

    - `x`：柱子位置。
    - `height`：柱子高度。
    - `width`：柱子宽度。
    - `color`, `edgecolor`, `align` 等。

  - **示例**：

    ```python
    plt.bar(['A', 'B', 'C'], [10, 20, 15], color='skyblue')
    ```

- **`plt.hist(x, bins=None, **kwargs)`**

  - **功能**：绘制直方图。

  - **用途**：展示数据分布或频率。

  - **参数**：

    - `x`：输入数据。
    - `bins`：分组数量或边界。
    - `density`：是否归一化。
    - `color`, `alpha` 等。

  - **示例**：

    ```python
    plt.hist(data, bins=30, color='green', alpha=0.7)
    ```

- **`plt.contour(X, Y, Z, levels=None, **kwargs)`**

  - **功能**：绘制等高线图（无填充）。

  - **用途**：展示二维网格数据的轮廓，如分类边界。

  - **参数**：

    - `X, Y`：网格坐标。
    - `Z`：网格值。
    - `levels`：等高线级别。
    - `colors`, `linewidths`, `cmap`。

  - **示例**：

    ```python
    plt.contour(X, Y, Z, levels=5, colors='k')
    ```

- **`plt.contourf(X, Y, Z, levels=None, **kwargs)`**

  - **功能**：绘制填充等高线图。

  - **用途**：显示网格值的颜色区域，如决策边界。

  - **参数**：

    - 同 `plt.contour`，另加 `cmap`（颜色映射）、`alpha`。

  - **示例**：

    ```python
    plt.contourf(X, Y, Z, cmap='Pastel2')
    ```

- **`plt.imshow(X, cmap=None, **kwargs)`**

  - **功能**：绘制图像或二维数组。

  - **用途**：显示矩阵数据、图像或热图。

  - **参数**：

    - `X`：二维数组。
    - `cmap`：颜色映射（如 `'viridis'`, `'hot'`）。
    - `interpolation`：插值方式（如 `'nearest'`）。

  - **示例**：

    ```python
    plt.imshow(matrix, cmap='gray')
    ```

- **`plt.pie(x, labels=None, **kwargs)`**

  - **功能**：绘制饼图。

  - **用途**：展示比例或百分比。

  - **参数**：

    - `x`：各部分值。
    - `labels`：标签。
    - `colors`, `autopct`（百分比格式）。

  - **示例**：

    ```python
    plt.pie([30, 40, 30], labels=['A', 'B', 'C'], autopct='%1.1f%%')
    ```

---

### 2. 图形布局与管理

这些函数用于组织图形和子图。

- **`plt.figure(figsize=None, **kwargs)`**

  - **功能**：创建新图形窗口。

  - **用途**：设置图形大小和属性。

  - **参数**：

    - `figsize`：宽度和高度（英寸），如 `(8, 6)`。
    - `dpi`：分辨率。

  - **示例**：

    ```python
    plt.figure(figsize=(10, 5))
    ```

- **`plt.subplot(nrows, ncols, index, **kwargs)`**

  - **功能**：创建并选择子图。

  - **用途**：在网格布局中绘制多个图表。

  - **参数**：

    - `nrows, ncols`：网格行数和列数。
    - `index`：子图位置（从 1 开始）。
    - `sharex`, `sharey`：共享轴。

  - **示例**：

    ```python
    plt.subplot(2, 1, 1)
    plt.plot([1, 2, 3])
    ```

- **`plt.subplots(nrows=1, ncols=1, figsize=None, **kwargs)`**

  - **功能**：一次性创建图形和子图数组。

  - **用途**：面向对象绘图，管理多子图。

  - **返回**：`Figure` 和 `Axes`（单个或数组）。

  - **示例**：

    ```python
    fig, axes = plt.subplots(2, 2)
    axes[0, 0].plot([1, 2, 3])
    ```

- **`plt.tight_layout()`**

  - **功能**：自动调整子图间距。

  - **用途**：防止标题或标签重叠。

  - **示例**：

    ```python
    plt.tight_layout()
    ```

- **`plt.close(fig=None)`**

  - **功能**：关闭图形窗口。

  - **用途**：释放内存，防止图形堆积。

  - **参数**：

    - `fig`：指定图形，默认关闭当前。

  - **示例**：

    ```python
    plt.close()
    ```

---

### 3. 图形设置与装饰

这些函数用于调整图形外观和添加标注。

- **`plt.title(label, fontsize=None, **kwargs)`**

  - **功能**：设置图形标题。

  - **用途**：描述图形内容。

  - **示例**：

    ```python
    plt.title('My Plot', fontsize=16)
    ```

- **`plt.xlabel(label, fontsize=None, **kwargs)`**

  - **功能**：设置 x 轴标签。

  - **用途**：标注 x 轴含义。

  - **示例**：

    ```python
    plt.xlabel('X Axis', fontsize=12)
    ```

- **`plt.ylabel(label, fontsize=None, **kwargs)`**

  - **功能**：设置 y 轴标签。

  - **用途**：标注 y 轴含义。

  - **示例**：

    ```python
    plt.ylabel('Y Axis', fontsize=12)
    ```

- **`plt.legend(loc='best', **kwargs)`**

  - **功能**：显示图例。

  - **用途**：标注不同数据系列。

  - **参数**：

    - `loc`：位置，如 `'upper right'`, `'best'`。
    - `labels`：自定义标签。

  - **示例**：

    ```python
    plt.plot(x, y, label='Data')
    plt.legend()
    ```

- **`plt.grid(True, **kwargs)`**

  - **功能**：显示网格线。

  - **用途**：辅助数据读取。

  - **参数**：

    - `which`：`'major'`, `'minor'`。
    - `color`, `linestyle`。

  - **示例**：

    ```python
    plt.grid(True, linestyle='--', alpha=0.7)
    ```

- **`plt.colorbar(mappable=None, **kwargs)`**

  - **功能**：添加颜色条。

  - **用途**：显示颜色映射的值范围。

  - **示例**：

    ```python
    plt.contourf(X, Y, Z)
    plt.colorbar()
    ```

- **`plt.clabel(contour, inline=True, **kwargs)`**

  - **功能**：为等高线添加数值标签。

  - **用途**：标注等高线值。

  - **示例**：

    ```python
    cs = plt.contour(X, Y, Z)
    plt.clabel(cs, fmt='%.1f')
    ```

- **`plt.tick_params(**kwargs)`**

  - **功能**：调整刻度标签和样式。

  - **用途**：隐藏或格式化刻度。

  - **参数**：

    - `labelbottom`, `labelleft`：显示/隐藏。
    - `length`, `width`, `color`。

  - **示例**：

    ```python
    plt.tick_params(labelbottom='off')
    ```

- **`plt.xlim(left=None, right=None)` / `plt.ylim(bottom=None, top=None)`**

  - **功能**：设置 x/y 轴范围。

  - **用途**：控制显示区域。

  - **示例**：

    ```python
    plt.xlim(0, 10)
    plt.ylim(-1, 1)
    ```

---

### 4. 数据处理与辅助函数

这些函数用于数据准备或绘图辅助。

- **`plt.text(x, y, s, **kwargs)`**

  - **功能**：在指定位置添加文本。

  - **用途**：标注数据点或说明。

  - **示例**：

    ```python
    plt.text(1, 2, 'Point A', fontsize=12)
    ```

- **`plt.annotate(s, xy, xytext=None, arrowprops=None, **kwargs)`**

  - **功能**：添加带箭头的注释。

  - **用途**：指向特定点并描述。

  - **示例**：

    ```python
    plt.annotate('Max', xy=(2, 3), xytext=(3, 4), arrowprops={'arrowstyle': '->'})
    ```

- **`plt.savefig(fname, dpi=None, **kwargs)`**

  - **功能**：保存图形到文件。

  - **用途**：导出 PNG、PDF 等格式。

  - **参数**：

    - `fname`：文件名（如 `'plot.png'`）。
    - `dpi`：分辨率。
    - `bbox_inches='tight'`：调整边距。

  - **示例**：

    ```python
    plt.savefig('output.png', dpi=300)
    ```

- **`plt.show()`**

  - **功能**：显示图形。

  - **用途**：渲染所有绘图。

  - **示例**：

    ```python
    plt.plot([1, 2, 3])
    plt.show()
    ```

---

### 5. 高级可视化

这些功能用于复杂或特定场景。

- **`plt.boxplot(x, **kwargs)`**

  - **功能**：绘制箱线图。

  - **用途**：展示数据分布和异常值。

  - **示例**：

    ```python
    plt.boxplot([data1, data2], labels=['A', 'B'])
    ```

- **`plt.errorbar(x, y, yerr=None, xerr=None, **kwargs)`**

  - **功能**：绘制带误差条的图。

  - **用途**：显示数据的不确定性。

  - **示例**：

    ```python
    plt.errorbar(x, y, yerr=0.1, fmt='o')
    ```

- **`plt.fill_between(x, y1, y2=0, **kwargs)`**

  - **功能**：填充两条曲线间的区域。

  - **用途**：高亮范围或区域。

  - **示例**：

    ```python
    plt.fill_between(x, y, 0, alpha=0.3)
    ```

- **`plt.streamplot(x, y, u, v, **kwargs)`**

  - **功能**：绘制流线图。

  - **用途**：展示向量场。

  - **示例**：

    ```python
    plt.streamplot(X, Y, U, V, color='b')
    ```

---

### 6. 常用功能与技巧

- **颜色管理**：

  - 颜色名称：`'red'`, `'blue'`, `'k'`（黑色）。

  - 十六进制：`'#ff0000'`。

  - 颜色映射：`plt.cm.viridis`, `plt.cm.Pastel2`。

  - 示例：

    ```python
    plt.scatter(x, y, c='tab:blue')
    ```

- **样式设置**：

  - 使用预定义样式：

    ```python
    plt.style.use('ggplot')
    ```

  - 自定义样式：

    ```python
    plt.rcParams['font.size'] = 12
    ```

- **多图叠加**：

  - 多次调用绘图函数（如 `plt.plot`, `plt.scatter`）叠加内容。

  - 示例：

    ```python
    plt.plot(x, y1, 'b-')
    plt.scatter(x, y2, c='r')
    ```

- **动态绘图**：

  - 使用 `FuncAnimation` 实现动画。

  - 示例：

    ```python
    from matplotlib.animation import FuncAnimation
    anim = FuncAnimation(fig, update, frames=100)
    ```

- **三维绘图**：

  - 使用 `mpl_toolkits.mplot3d`：

    ```python
    from mpl_toolkits.mplot3d import Axes3D
    ax = plt.subplot(projection='3d')
    ax.plot3D(x, y, z)
    ```

---

### 总结

- **核心绘图**：
  - `plot`, `scatter`, `bar`, `hist`, `contour`, `contourf`, `imshow`, `pie`。
- **布局管理**：
  - `figure`, `subplot`, `subplots`, `tight_layout`, `close`。
- **图形装饰**：
  - `title`, `xlabel`, `ylabel`, `legend`, `grid`, `colorbar`, `clabel`, `tick_params`, `xlim`, `ylim`.
- **辅助功能**：
  - `text`, `annotate`, `savefig`, `show`.
- **高级绘图**：
  - `boxplot`, `errorbar`, `fill_between`, `streamplot`, 3D 绘图，动画。
- **用途**：
  - 数据分析、机器学习、科学可视化、报告制作。